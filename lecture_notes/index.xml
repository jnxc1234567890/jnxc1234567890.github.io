<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lecture_notes on</title><link>https://jnxc1234567890.github.io/lecture_notes/</link><description>Recent content in Lecture_notes on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jnxc1234567890.github.io/lecture_notes/index.xml" rel="self" type="application/rss+xml"/><item><title>ECE120 Lecture 1 - Abstraction and Representation</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-1/</guid><description>Abstraction Layer While constructing computers, we can use the idea of abstraction to make things easier: ![[lecture_notes/ECE120/images/Pasted image 20220414144524.png]]
Representations Definition for representation The mapping from one form to another is called a representation.</description></item><item><title>ECE120 Lecture 14</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-14/</guid><description>Power of Two Checker How to check whether a number is the power of 2? It&amp;rsquo;s very easy for us human to do that because power of 2 has only one 1 bit in binary.</description></item><item><title>ECE120 Lecture 15</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-15/</guid><description/></item><item><title>ECE120 Lecture 16 - Storing a Bit</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-16/</guid><description>Sequential Logic Combinational logic allows us to solve the following type of problem:
given a set of bits as input how can we combine them to produce other sets of bits (Boolean expressions)?</description></item><item><title>ECE120 Lecture 17 - Static Hazards and Registers</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-17/</guid><description>Static Hazards (Optional) Registers A register is a storage element composed from one or more flip-flops operating on a common clock.</description></item><item><title>ECE120 Lecture 18 - Serialization</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-18/</guid><description>Serial Design Example 1: Example 2:</description></item><item><title>ECE120 Lecture 19 - FSM and Binary Counter</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-19/</guid><description>FSM Definition of FSM A Finite State Machine consists of five parts:
Finite set of states Set of inputs Set of outputs(only dependent on state) Set of transition rules Methods for calculating outputs Digital FSM We implement FSM in digital system as sequential logic circuits.</description></item><item><title>ECE120 Lecture 2 - Numerical Representation</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-2/</guid><description>Unsigned [[lecture_notes/ECE120/ECE120 Lecture 1#Definition for representation|Representation]] In order to represent an integer, the computer uses base-2 numbers from mathematics (aka. binary).</description></item><item><title>ECE120 Lecture 20</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-20/</guid><description>Machine Models There&amp;rsquo;re two types of FSMs in history:
Moore machine, outputs depend only on state Mealy machine, outputs may also depend on inputs</description></item><item><title>ECE120 Lecture 21 - FSM for Lab 9</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-21/</guid><description/></item><item><title>ECE120 Lecture 24 - Memory</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-24/</guid><description>Storing Lots of Bits The computer we’re going to design has a lot of places to store bits. Each place stores 32 bits.</description></item><item><title>ECE120 Lecture 25 - From FSM to Computer</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-25/</guid><description>FSM and Code Theoretically, finite state machines can solve any kinds of problems that computer language codes can solve. (Because computers are also finite state machines!</description></item><item><title>ECE120 Lecture 26 - The von Neumann Model</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-26/</guid><description>The von Neumann Model In 1946, John von Neumann invented a model for computer organization in which a computer comprises five parts.</description></item><item><title>ECE120 Lecture 27 - Instruction formats and instruction processing</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-27/</guid><description>Instruction Formats LC-3 ISA In all, LC-3 ISA has three kinds of opcodes:
operations data movement control flow Operations ADD AND NOT</description></item><item><title>ECE120 Lecture 28</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-28/</guid><description/></item><item><title>ECE120 Lecture 29 - LC-3 binary program analysis: counting to 10</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-29/</guid><description>From FSM to LC-3 We have already implemented a binary counter using FSM in [[lecture_notes/ECE120/ECE120 Lecture 19|Lecture 19]].
But now we&amp;rsquo;re going to try something different!</description></item><item><title>ECE120 Lecture 3</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-3/</guid><description/></item><item><title>ECE120 Lecture 30</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-30/</guid><description/></item><item><title>ECE120 Lecture 32 - LC-3 Programming example: letter frequency counter</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-32/</guid><description>Letter Frequency Counter We wish to design a program that:
given an ASCII string (a sequence of characters terminated by a NUL, ASCII x00) count the occurrences of each letter (regardless of case) and count the number of non-alphabetic characters.</description></item><item><title>ECE120 Lecture 4</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-4/</guid><description/></item><item><title>ECE120 Lecture 5</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-5/</guid><description/></item><item><title>ECE120 Lecture 6</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-6/</guid><description/></item><item><title>ECE120 Lecture 7</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-7/</guid><description>Program Analysis Being able to read code is a necessary skill.
In the real world, codes are often poorly commented (few people are interested in commenting their codes).</description></item><item><title>ECE120 Lecture 8</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-Lecture-8/</guid><description>MOSFET All the digital electronics today use MOSFETs.
There&amp;rsquo;re two kinds, named after the charge carrier.
n(egative)-type p(ositive)-type !</description></item><item><title>ECE120 MOC</title><link>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-MOC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECE120/ECE120-MOC/</guid><description>Course Description ECE120: Intro to Computing Systems is a UIUC course about the structure of computing systems.
Lecture Notes [[lecture_notes/ECE120/ECE120 Lecture 1|Lecture 1]] [[lecture_notes/ECE120/ECE120 Lecture 2|Lecture 2]] [[lecture_notes/ECE120/ECE120 Lecture 3|Lecture 3]] [[lecture_notes/ECE120/ECE120 Lecture 4|Lecture 4]] [[lecture_notes/ECE120/ECE120 Lecture 5|Lecture 5]] [[lecture_notes/ECE120/ECE120 Lecture 6|Lecture 6]] [[lecture_notes/ECE120/ECE120 Lecture 7|Lecture 7]] [[lecture_notes/ECE120/ECE120 Lecture 8|Lecture 8]] [[Lectures/ECE120/Lecture 9|Lecture 9]] [[Lectures/ECE120/Lecture 10|Lecture 10]] [[Lectures/ECE120/Lecture 11|Lecture 11]] [[Lectures/ECE120/Lecture 12|Lecture 12]] [[Lectures/ECE120/Lecture 13|Lecture 13]] [[lecture_notes/ECE120/ECE120 Lecture 14|Lecture 14]] [[lecture_notes/ECE120/ECE120 Lecture 15|Lecture 15]] [[lecture_notes/ECE120/ECE120 Lecture 16|Lecture 16]] [[lecture_notes/ECE120/ECE120 Lecture 17|Lecture 17]] [[lecture_notes/ECE120/ECE120 Lecture 18|Lecture 18]] [[lecture_notes/ECE120/ECE120 Lecture 19|Lecture 19]] [[lecture_notes/ECE120/ECE120 Lecture 20|Lecture 20]] [[lecture_notes/ECE120/ECE120 Lecture 21|Lecture 21]] [[lecture_notes/ECE120/ECE120 Lecture 24|Lecture 24]] [[lecture_notes/ECE120/ECE120 Lecture 25|Lecture 25]] [[lecture_notes/ECE120/ECE120 Lecture 26|Lecture 26]] [[lecture_notes/ECE120/ECE120 Lecture 27|Lecture 27]] Lab Notes [[Lab 1]] [[Lab 2]] [[Lab 3]] Homework Notes</description></item><item><title>ECON102 Lecture 1</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-1/</guid><description/></item><item><title>ECON102 Lecture 2</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-2/</guid><description/></item><item><title>ECON102 Lecture 3</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-3/</guid><description/></item><item><title>ECON102 Lecture 4</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-4/</guid><description/></item><item><title>ECON102 Lecture 5</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-5/</guid><description/></item><item><title>ECON102 Lecture 6</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-6/</guid><description/></item><item><title>ECON102 Lecture 7 - Trade</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-7/</guid><description>Production Possibilities Curve Production possibilities curve (PPC) shows the relationship between the maximum production of one good for a given level of production of another good.</description></item><item><title>ECON102 Lecture 8 - Externalities</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-Lecture-8/</guid><description>Market Failures: Externalities There are important cases in which free markets fail to maximize social surplus. We call such cases market failures.</description></item><item><title>ECON102 MOC</title><link>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-MOC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ECON102/ECON102-MOC/</guid><description>Course Description ECON102: Microeconomics Principles
Lecture Notes [[lecture_notes/ECON102/ECON102 Lecture 1|Lecture 1 - Introduction]] [[Lecture 2 - Optimization &amp;amp; Demand &amp;amp; Supply]] [[Lecture 3 - Consumer Side]] [[Lecture 4 - ]] [[Lecture 5]] [[Lecture 6]] [[lecture_notes/ECON102/ECON102 Lecture 7|Lecture 7 - Trade]] [[lecture_notes/ECON102/ECON102 Lecture 8|Lecture 8- Externalities]]</description></item><item><title>ML Seminar 2022.4.16</title><link>https://jnxc1234567890.github.io/lecture_notes/ML_seminars/ML-Seminar-2022.4.16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ML_seminars/ML-Seminar-2022.4.16/</guid><description>Group Activity Recognition Predicting group activity.
Input: RGB and optical flow Output: Group Activity Label Label: Bounding Box and individual actions Settings of Dataset:</description></item><item><title>ML Seminar 2022.4.22</title><link>https://jnxc1234567890.github.io/lecture_notes/ML_seminars/ML-Seminar-2022.4.22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jnxc1234567890.github.io/lecture_notes/ML_seminars/ML-Seminar-2022.4.22/</guid><description>Representation Matters The way how data represented is crucial to machine learning.
![[lecture_notes/ML_seminars/images/Pasted image 20220422224849.png]]
Above is an example of how transforming from Cartesian coordinate to Polar corrdinate helps improving performance of Logistic Regression networks.</description></item></channel></rss>