{"/":{"title":"Niceme's Wiki","content":"## About the Wiki\n\nWelcome to my personal wikipedia!\n\n## MOC of the Wiki\nThe wiki includes knowledge from these subjects:\n- Computer Science\n\t1. [Computer Architecture](wikipages/Computer%20Architecture.md)\n\t2. [Software Engineering](wikipages/Software%20Engineering.md)\n- Mathematics\n\t1. [Calculus](wikipages/Calculus.md)\n- Electrical Engineering\n- Social Science\n\t1. [[wikipages/Economics|Economics]]\n\n\n## Content Lists\nIf you prefer browsing the contents of this site through a list instead of a graph, you can find content lists here too:\n\n- [All Notes](/notes)\n- [All Wiki Pages](/wikipages)","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-1":{"title":"ECE120 Lecture 1 - Abstraction and Representation","content":"## Abstraction Layer\nWhile constructing computers, we can use the idea of abstraction to make things easier:\n![[lecture_notes/ECE120/images/Pasted image 20220414144524.png]]\n\n## Representations\n\n### Definition for representation\nThe mapping from one form to another is called a representation.\n\n### Necessary condition of representations\n- Well-defined\n- Unambiguous","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-14":{"title":"ECE120 Lecture 14","content":"---\n\n## Power of Two Checker\n\nHow to check whether a number is the power of 2? It's very easy for us human to do that because power of 2 has only one 1 bit in binary.\n\nThe same applies for a circuit, we just need to check how many 1 bits are there in a number!\nWe would still use a bit-sliced design (but in **2**-bit sliced). To represent all the situations, we'll need 2 bits.\n\n| C1  | C0  | meaning             |\n|","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-15":{"title":"ECE120 Lecture 15","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-16":{"title":"ECE120 Lecture 16","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-17":{"title":"ECE120 Lecture 17","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-18":{"title":"ECE120 Lecture 18","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-19":{"title":"ECE120 Lecture 19","content":"---\n\n## FSM\n### Definition of FSM\nA FSM consists of five parts:\n1. Finite set of states\n2. Set of inputs\n3. Set of outputs(only dependent on state)\n4. Set of transition rules\n5. Methods for calculating outputs\n\n### Digital FSM\nWe implement FSM in digital system as sequential logic circuits.\n\n### Keyless Entry Example\n#### State Table\n\n| meaning              | state    | driver’s door | other doors | alarm on? |\n|","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-2":{"title":"ECE120 Lecture 2 - Numerical Representation","content":"## Unsigned [[lecture_notes/ECE120/ECE120 Lecture 1#Definition for representation|Representation]]\nIn order to represent an integer, the computer uses base-2 numbers from mathematics (aka. binary).\nDue to hardware limitations, we cannot create representations that use arbitrary number of bits. Therefore, we use some fixed numbers of bits to represent a certain group of numbers, which introduced leading 0s.\ne.g.\n$$\n\\begin{align}\n17_{10}=00010001_2 \\\\\n42_{10}=00101010_2 \n\\end{align}\n$$\n### Conversion from Binary to Decimal\nThe conversion from binary to decimal is quite straight forward, because the $i$th bit in binary represents $2^{i-1}$ .\ne.g. Convert $01001_2$\n$$\n01001_2 = (0 \\cdot 2^4 + 1 \\cdot 2^3+0 \\cdot 2^2+0 \\cdot 2^1+1 \\cdot 2^0)_{10}=9_{10}\n$$\n\n### Conversion from Decimal to Binary\nIt might not seem so straightforward as the previous one, but the core idea is the same.\ne.g. Convert $9_{10}$ to a 5-bit binary.\n$$\n\\begin{align}\n\u0026\\text{Assume } 9_{10} = a_4\\cdot 2^4 + a_3\\cdot 2^3 + a_2\\cdot 2^2+a_1\\cdot 2^1+a_0\\cdot2^0. \\\\\n\u0026\\text{Clearly, the parity of the number determined }a_0. \\\\\n\u0026(9-a_0) \\div 2 = a_4\\cdot 2^3 + a_3\\cdot 2^2 + a_2\\cdot 2^1+a_1\\cdot 2^0 \\\\\n\u0026\\text{Clearly, the parity of the number determined } a_1. \\\\\n\u0026((9-a_0)-a_1) \\div 2=a_4\\cdot 2^2 + a_3\\cdot 2^1 + a_2\\cdot 2^0 \\\\\n\u0026\\text{ Clearly, the parity of the number determined } a_2. \\\\\n\u0026\\cdots\n\\end{align}\n$$\n\n## Addition of Unsigned Representation\nBinary addition is almost the same as decimal addition.\ne.g. $01001_2+01110_2$\n$$\n\\begin{align}\n_1\\quad \\quad  \u0026\\\\\n01001\u0026\\\\\n+01110\u0026\\\\\n\\hline\n10111\u0026\n\\end{align}\n$$\nHowever, sometimes things go wrong.\ne.g. $01001_2+11110_2$\n$$\n\\begin{align}\n_{1\\ 1} \\quad \\quad  \u0026\\\\\n01001\u0026\\\\\n+11110\u0026\\\\\n\\hline\n①10111\u0026\n\\end{align}\n$$\nNote there is a carry out 1. Because of bit limitation, it did not appear in the final result, causing a mismatch. This kind of phenomena is called overflow.\n\nTo sum up, the addition result of $N$ bit binary is\n$$\nS = (A+B)\\mod 2^N\n$$\n\n## 2's Complement\nHere comes the question, how to store negative numbers?\n\nThe easiest way is [[Sign-Magnitude]]. But our topic today focuses on 2's complement representation, which is the most widely used representation in computers nowadays.\n\nThe key concept of 2's complement representation is to make use of the same addition component as unsigned representation, which is to say,\n$$\n\\begin{align*}\n\u0026\\text{For a negative number }-k, \\text{ we wish to find its reprentation }P_k.\\\\\n\u0026\\text{So that }\\forall N \\in \\mathbb{Z}, \\text{we have }(-k+N)\\equiv(P_{k}+N) \\mod 2^{N}.\n\\end{align*}\n$$\nIt's easy to find that the appropriate $P_{k}$ should be $2^{N}-k$.\n\nThe representation of $P_{k}=2^{N}-k$ is called **2' complement** representation. It has the advantage of using the same addition circuit with unsigned representation.\n\n## Sign-Magnitude (optional)\nSign-Magnitude representation is used","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-20":{"title":"ECE120 Lecture 20","content":"## Machine Models","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-21":{"title":"ECE120 Lecture 21","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-22":{"title":"ECE120 Lecture 22 - Memory","content":"---\n## Storing Lots of Bits\nThe computer we’re going to design has a lot of places to store bits. Each place stores 32 bits. We need names for the places. The best way is to assign them with a number.\n\nBut with so many bits, how to access one or multiple of them? We need to build a circuit that lets us read and write the bits stored in each place.\n\nThe circuit should have:\n- Input ADDR: Tell the circuit the address we want\n- Output DATA-OUT: The data stored in ADDR.\n- Input DATA-IN: The data we wish to store in ADDR.\n- Input WE: Tell the circuit whether we want to read or write (write enable).\n\n## Memory\nThe circuit we proposed is called **memory**. The symbol diagram below well illustrates it.\n![[lecture_notes/ECE120/images/Pasted image 20220414213722.png]]\n\nCS means “chip select”. If CS = 1, the memory reads or write; if CS = 0, the memory does nothing.\n\n### Certain Restrictions in ECE120\n1. The memory we talk about in ECE120 is **Random Access Memory (RAM)**. Addresses can be read/written (accessed) in any order and the time required to read/write an address does not depend (much) on the address.\n2. Besides, we consider only volatile forms of RAM, which lose their bits if electrical power is turned off.\n3. There're mainly two types of RAM:\n\t- **Static RAM (SRAM)** uses a two-inverter loop to store a bit retains bit indefinitely while powered. (faster, less dense)\n\t- **Dynamic RAM (DRAM)** uses a capacitor to store a bit loses bit over time (_even with electricity!_), so must be refreshed (rewritten) periodically. (slower, more dense)\n4. We only talk about SRAM here.\n\n## SRAM Cell\nThis is a SRAM cell.\n![[lecture_notes/ECE120/images/Pasted image 20220414214504.png]]\n\nTwo n-type MOSFETs connect the two inverters to the bit lines ($BIT$ and $BIT’$). When $SELECT = 1$, the bit is connected to the bit lines. When $SELECT = 0$, this cell is disconnected.\n\n### Write a Bit\nTo write a bit in SRAM cell, simply set $SELECT = 1$, then set bit lines held at opposite values. This will force the inverters to store the bit.\n![[lecture_notes/ECE120/images/Pasted image 20220414214705.png]]\n\nThis operation is a bit dangerous, because it wires together outputs! Changing one bit means short circuit, so the system must be designed carefully.\n\n### Read a Bit\nTo read bits from the cell, $BIT$ and $BIT'$ should be left floating. Then $SELECT=1$ will write bits to two lines.\n![[lecture_notes/ECE120/images/Pasted image 20220414215030.png]]\n\nNormally, to speed up reads, bit lines are pre-charged to $V_{dd}/2$, and sense amplifiers (analog devices) amplify any changes in voltage between bit lines to 0/1.\n\n### 6T Cell\nThe SRAM cell design is called 6T Cell because it has 6 transistors. The designed is commonly used due to its balance of speed and good reliability with small size.\n\n## Memory Control Circuit\nBelow is a $16\\times 1$ memory.\n![[lecture_notes/ECE120/images/Pasted image 20220414215508.png]]\n\nWhen $CS=1$, the decoder activates the specified cell and then the read/write logic is ready to read or write to the specified cell.\n\n### Non-Clocked Memory\nRemind that memory is not clocked by $CLK$ signal. So we need to ensure a read/write has finished before the next move.\n\nThere're two ways to accomplish this:\n1. The memory designer specifies a minimum wait time (in the datasheet) for a read/write to complete.\n2. Or the memory raises an output (called R in Patt and Patel) to indicate that it is Ready for another operation.\n\n### Balance of Speed and Size\nWhen the memory gets larger, the decoder will expand with size. This causes the circuit size very large.\n\nWe can use a technique called **Coincident Selection** to significantly reduce the number of gates required. The technique is simply putting a new decoder like the graph below.\n![[lecture_notes/ECE120/images/Pasted image 20220414220058.png]]\n\n### Expanding Memory\n#### More Addresses\nGiven two $2^{k}×N$-bit memories, construct a $2^{k+1}×N$-bit memory.\n![[lecture_notes/ECE120/images/Pasted image 20220414220617.png]]\n#### Wider Addressability\nGiven two $2^{k}×N$-bit memories, construct a $2^{k}×(2N)$-bit memory.\n![[lecture_notes/ECE120/images/Pasted image 20220414220633.png]]\n\n## Tri-State Buffer\nThe small triangle is a **tri-state buffer**.\n![[lecture_notes/ECE120/images/Pasted image 20220414221133.png]]\n\n| EN  | IN  | OUT |\n|","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-23":{"title":"ECE120 Lecture 23 - From FSM to Computer","content":"## FSM and Code","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-3":{"title":"ECE120 Lecture 3","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-4":{"title":"ECE120 Lecture 4","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-5":{"title":"ECE120 Lecture 5","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-6":{"title":"ECE120 Lecture 6","content":"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-7":{"title":"ECE120 Lecture 7","content":"---\n## Program Analysis\nBeing able to read code is a necessary skill.\nIn the real world, codes are often poorly commented (few people are interested in commenting their codes). Therefore, it would be nice if we could interpret others' codes without comments.\n```c\n/* Adapted from V. Kindratenko's notes on 30 August 2016. */\n#include \u003cstdio.h\u003e /* needed for printf and scanf */\nint main()\n{\n int A;\n char B;\n int C;\n int D;\n printf (\"Enter two numbers separated by a character: \");\n if (3 != scanf (\"%d %c %d\", \u0026A, \u0026B, \u0026C)) {\n printf (\"Please try again.\\n\");\n /* Program failed. */\n return 3;\n }\n if ('+' == B) {\n D = A + C;\n } else if ('-' == B) {\n D = A - C;\n } else if ('/' == B) {\n D = A / C;\n } else if ('*' == B) {\n D = A * C;\n } else {\n printf (\"Invalid choice '%c'\\n\", B);\n /* Program failed. */\n return 2;\n }\n printf (\"answer: %d\\n\", D); \n /* End the program successfully. */\n return 0;\n}\n```\n\n## Testing Programs\nIn the world of programming, it's a wise choice to test your programs before true submission.\n__Brooks' Rule of Thumb__:\n- 1/3 planning and design \n- 1/6 writing the program \n- 1/2 testing\n\nIt's really no kidding. Programmers often make small mistakes in programming and it will take a long testing period to find out those mistakes.\n\n\n## Floating Points are Tricky!\nAs we have shown [[Lectures/ECE120/Lecture 4#Danger in floating point numbers|before]], floating point numbers are tricky to handle.\nHere is an example in C Programming:\n\nSuppose we wish to find $\\int^{1}_{-1}{(x^{2}+2x+3)} \\mathrm{d}x$ by using C Programming.\nWe could use an approximation of [[Riemann Sum]]\n```c\n#include \u003cstdio.h\u003e\n\nint main()\n{\n int n = 100; /* hardcoded number of Riemann sum terms */\n float a = -1.0f; /* hardcoded [a,b] */\n float b = 1.0f;\n float s = 0.0f; /* computed integral value */\n int i; /* loop counter */\n float x; /* x and y=f(x) */\n float y;\n float dx = (b - a) / n; /* width of rectangles */\n /* Sum n rectangles. */\n for (i = 0; n \u003e i; i = i + 1) {\n /* x values are equally spaced from a to b. */\n x = a + dx * i;\n /* y values are f(x). */\n y = x * x + 2 * x + 3;\n /* Rectangle is y high and dx wide. */\n s = s + y * dx;\n }\n printf (\"%f\\n\", s);\n return 0;\n}\n```\nTheoretically, as ```n``` gets larger, the result will become more accurate.\n\n![[Bin/Photos/ECE120Lec07Img1.png]]\nThis is also how things develop when $\\mathrm{n} \u003c 10^{6}$. \n\nHowever, when $\\mathrm{n}\u003e 10^{6}$ , things becomes wired.\n![[Bin/Photos/ECE120Lec07Img2.png]]\n\nWhy? Note an important part of the code above\n```c\ns = s + y * dx;\n```\nAs ```n``` gets larger, ```y * dx``` gets smaller and smaller, and as we've already mentioned earlier, a super-large number adding a super-small number causes errors in floating point.\n\n## Bit-wise Calculation\nAs we have learnt previously in Boolean Operations, C supports multiple bit-wise operations. We can use this interesting property to do efficient truth table printing:\n```c\n#include \u003cstdint.h\u003e\n#include \u003cstdio.h\u003e\nint main ()\n{\n /*\n * The input variables A, B, and C are 8-bit unsigned values.\n * We use each bit to represent a possible combination of the\n * three variables.  Bit 7 of each is set to a 1, for example.\n * Bit 4 of A is set to 1, while bits 4 of B and C are set to 0.\n * In this way, we cover all entries of the truth table for\n * F(A,B,C).\n */\n uint8_t A = 0xF0; /* input variable A                   */\n uint8_t B = 0xCC; /* input variable B                   */\n uint8_t C = 0xAA; /* input variable C                   */\n uint8_t F; /* the function F                     */\n int32_t i; /* truth table row iteration variable */\n /*\n * Compute all possible values of function F using one statement.\n *    F(A,B,C) = (A+B)(A'+C')\n */\n F = ((A | B) \u0026 ((~A) | (~C)));\n /* Print a truth table for F. */\n printf (\"A B C | F\\n\");\n printf (\"","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-Lecture-8":{"title":"ECE120 Lecture 8","content":"---\n\n## MOSFET\n\nAll the digital electronics today use MOSFETs.\n\nThere're two kinds, named after the charge carrier.\n\n- n(egative)-type\n- p(ositive)-type\n\n![[lecture_notes/ECE120/images/Pasted image 20220415113217.png|300]]\n\n\u003cimg src=\"images/Pasted image 20220415113217.png\" /\u003e\n\nAn n-type MOSFET turns on if the Gate voltage exceeds threshold while the p-type do the opposite.\n\nWe only need two kinds of voltages to represent binary:\n\n- $0V$ , binary 0\n- $V_{dd}$ , binary 1\n\n## CMOS Logic Gate\nGates are mostly based on Complementary MOS (CMOS), which is the **complementary structure** of p-type and n-type MOSFETs.\n\n#### NOT Gate\n![[lecture_notes/ECE120/images/Pasted image 20220415113412.png]]\n#### NOR Gate\n![[lecture_notes/ECE120/images/Pasted image 20220415113358.png]]\n#### NAND Gate\n![[lecture_notes/ECE120/images/Pasted image 20220415113425.png]]\n\n## Optimization of Boolean Expressions\n\n### What's the best way to write F?\nSuppose we have:\n$$\nF = AB’C + ABC’ + ABC\n$$\nThe function $F$ can also be written in many other ways:\n$$\n\\begin{align*}\n\u0026F = AB + AC\\\\\n\u0026F = A (B + C)\\\\\n\u0026\\cdots\n\\end{align*}\n$$\nHow to determine the best way?\n\nAs a matter of fact, this is not a valid question. Because when evaluating a method, the metric is important. There're mainly 4 metrics used in logic gate construction.\n\n- area / size / cost\n- performance / speed\n- power / energy consumption\n- complexity / reliability\n\n### Area Heuristics\n1. Count literals (A, A’, B, B’, C, C’)\n2. Add the number of operations (not including complements for literals).\n\n### Delay(Speed) Heuristics\n- Find the maximum number of gates between any input and any output.\n\n### Power and Complexity\nThese two metrics are beyond our class’ scope. You’ll see power in ECE385.\n\nOne heuristic for power uses the fact that current flows when a transistor switches on/off and uses simulation to estimate the number of times that happens. \n\nComplexity is hard to measure, and is usually based on experience.\n\n### Answer the question above\n\n| From of $F$ | Lits | Ops | Area | Delay |\n|","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECE120/ECE120-MOC":{"title":"ECE120 MOC","content":"## Course Description\nECE120: Intro to Computing Systems is a UIUC course about the structure of computing systems.\n\n## Lecture Notes\n1. [[lecture_notes/ECE120/ECE120 Lecture 1|Lecture 1]]\n2. [[lecture_notes/ECE120/ECE120 Lecture 2|Lecture 2]]\n3. [[lecture_notes/ECE120/ECE120 Lecture 3|Lecture 3]]\n4. [[lecture_notes/ECE120/ECE120 Lecture 4|Lecture 4]]\n5. [[lecture_notes/ECE120/ECE120 Lecture 5|Lecture 5]]\n6. [[lecture_notes/ECE120/ECE120 Lecture 6|Lecture 6]]\n7. [[lecture_notes/ECE120/ECE120 Lecture 7|Lecture 7]]\n8. [[lecture_notes/ECE120/ECE120 Lecture 8|Lecture 8]]\n9. [[Lectures/ECE120/Lecture 9|Lecture 9]]\n10. [[Lectures/ECE120/Lecture 10|Lecture 10]]\n11. [[Lectures/ECE120/Lecture 11|Lecture 11]]\n12. [[Lectures/ECE120/Lecture 12|Lecture 12]]\n13. [[Lectures/ECE120/Lecture 13|Lecture 13]]\n14. [[lecture_notes/ECE120/ECE120 Lecture 14|Lecture 14]]\n15. [[lecture_notes/ECE120/ECE120 Lecture 15|Lecture 15]]\n16. [[lecture_notes/ECE120/ECE120 Lecture 16|Lecture 16]]\n17. [[lecture_notes/ECE120/ECE120 Lecture 17|Lecture 17]]\n18. [[lecture_notes/ECE120/ECE120 Lecture 18|Lecture 18]]\n19. [[lecture_notes/ECE120/ECE120 Lecture 19|Lecture 19]]\n20. [[lecture_notes/ECE120/ECE120 Lecture 20|Lecture 20]]\n21. [[lecture_notes/ECE120/ECE120 Lecture 21|Lecture 21]]\n22. [[lecture_notes/ECE120/ECE120 Lecture 22|Lecture 22]]\n23. [[lecture_notes/ECE120/ECE120 Lecture 23|Lecture 23]]\n\n## Lab Notes\n1. [[Lab 1]]\n2. [[Lab 2]]\n3. [[Lab 3]]\n\n## Homework Notes","lastmodified":"2022-04-15T05:52:48.06297141Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-1":{"title":"ECON102 Lecture 1","content":"","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-2":{"title":"ECON102 Lecture 2","content":"","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-3":{"title":"ECON102 Lecture 3","content":"","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-4":{"title":"ECON102 Lecture 4","content":"","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-5":{"title":"ECON102 Lecture 5","content":"","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-6":{"title":"ECON102 Lecture 6","content":"","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-7":{"title":"ECON102 Lecture 7 - Trade","content":"---\n\n## Production Possibilities Curve\n**Production possibilities curve (PPC)** shows the relationship between the maximum production of one good for a given level of production of another good.\n\nBelow is an example of PPC between computer programs and websites for a person.\n![[lecture_notes/ECON102/images/Pasted image 20220414180225.png]]\n\n### Opportunity Cost on PPC\n$$\n\\text{Opportunity Cost}_{\\text{Websites}}=\\frac{\\text{Loss in computer programs}}{\\text{Gain in Websites}}\n$$\n## Reasons behind Trade\n### Comparative Advantage\nLook at the PPC of two persons below:\n![[lecture_notes/ECON102/images/Pasted image 20220414180740.png]]\n\nIf we calculate the opportunity costs of two persons\n\n| Individual | Website opportunity cost | Computer program opportunity cost |\n|","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-Lecture-8":{"title":"ECON102 Lecture 8 - Externalities","content":"## Market Failures: Externalities\nThere are important cases in which free markets fail to maximize social surplus. We call such cases market failures. One of them is externality.\n\n**Externality** is the uncompensated impact of one person’s actions on the well-being of a bystander. _e.g._ smoking in public places without considering impact on others.\n\nMarket is **NOT** efficient when there are externalities. Because self-interested buyers and sellers neglect the external effects of their actions.\n\n### Negative Externalities\n**Negative externality** is when the effect on bystanders is adverse.\n\n#### Air Pollution\nThe firm does not bear the full cost of its production, and so will produce more than the socially efficient quantity.\n\n#### Other Examples\n1. Your neighbor’s barking dog \n2. Late-night loud video games noises from the dorm room next to yours \n3. Noise pollution from construction projects near your house \n4. Talking on cell phone while driving makes the roads less safe for others \n5. Health risk to others from second-hand smoke\n\n### Positive Externalities\n**Positive Externality** is when the effect on bystanders is beneficial.\n\n#### Benefit of Education\nA more educated population benefits society: \n- lower crime rates: educated people have more opportunities, so less likely to rob and steal \n- better government: educated people make better-informed voters\n\nHowever, people do not consider these external benefits when deciding how much education to “purchase”, so the market equilibrium education is low.\n\n#### Other Examples\n1. Being vaccinated against contagious diseases protects not only you, but people who visit the restaurants or cinemas \n2. R\u0026D creates knowledge others can use\n\n### Example: Gasoline Market\nIn the market of gasoline, there is additional cost to the society, or externalities in the gasoline transaction. These factors are not considered in previous analysis, so how to add them to our analysis?\n\n#### Analysis of Negative Externalities\nIf taken the factors of externalities into account, the cost of society should also be considered, shifting the cost curve (supply curve) upward.\n![[lecture_notes/ECON102/images/Pasted image 20220415132333.png]]\n\nTherefore, we'll find that\n$$\nQ_{\\text{private}}\u003eQ_{\\text{social}}\n$$\n![[lecture_notes/ECON102/images/Pasted image 20220415132423.png]]\n\n#### Internalizing the Externality\nOne fundamental theme unites the multiple solutions to externalities, is try to let economic agents **internalizing** the externality, meaning individuals or companies take into account the full costs and benefits of their actions because of some public or private incentive.\n\nWhen the external effects of their actions are internalized, the general result is that the market equilibrium moves toward higher social well-being.\n\n#### Pigou Taxes\nSuppose we impose a 1 per gallon tax on gasoline. The 1/gallon tax on sellers makes sellers’ costs equal to social costs. When market participants must pay social costs, the market equilibrium matches the social optimum.\n\nSuch taxes are called **Pigou taxes**.\n\n#### Analysis of Positive Externality\nSimilarly, we can find the effect of positive externality on the market.\n![[lecture_notes/ECON102/images/Pasted image 20220415134321.png]]\n\nWe'll find that\n$$\nQ_{\\text{private}}\u003cQ_{\\text{social}}\n$$\n\n## Private Solution to Externalities\n\n\n\n## Public Policies to Externalities","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/lecture_notes/ECON102/ECON102-MOC":{"title":"ECON102 MOC","content":"## Course Description\nECON102: Microeconomics Principles\n\n## Lecture Notes\n1. [[lecture_notes/ECON102/ECON102 Lecture 1|Lecture 1 - Introduction]]\n2. [[Lecture 2 - Optimization \u0026 Demand \u0026 Supply]]\n3. [[Lecture 3 - Consumer Side]]\n4. [[Lecture 4 - ]]\n5. [[Lecture 5]]\n6. [[Lecture 6]]\n7. [[lecture_notes/ECON102/ECON102 Lecture 7|Lecture 7 - Trade]]\n8. [[lecture_notes/ECON102/ECON102 Lecture 8|Lecture 8- Externalities]]","lastmodified":"2022-04-15T05:52:48.070971438Z","tags":null},"/wikipages/Calculus":{"title":"Calculus","content":"## Courses\n1. [[MATH231 MOC|MATH231]]\n2. MATH241\n3. MATH286\n\n## Books\n1. [[Calculus - James Stewart|Calculus - James Stewart]]\n\n## Wiki of Calculus\n- Single Variable Calculus\n\t- Differential Calculus\n\t\t- [Limits](wikipages/Limits.md)\n\t\t- [Derivatives](wikipages/Derivatives.md)\n\t\t- [Rules of Differentiation](wikipages/Rules%20of%20Differentiation.md)\n\t\t- Applications of Differentiation\n\t- Integral Calculus\n\t\t- [Integrals](wikipages/Integrals.md)\n\t\t- [Techniques of Integration](wikipages/Techniques%20of%20Integration.md)\n\t\t- Applications of Integration\n\t- Sequence and Series\n\t\t- [Sequence and Series](wikipages/Sequence%20and%20Series.md)\n- Multi Variable Calculus\n\t-","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Computer-Architecture":{"title":"Computer Architecture","content":"## Courses\n1. [[lecture_notes/ECE120/ECE120 MOC|ECE120 MOC]]\n\n## Books\n1. Intro to Computing Systems - Patt\n\n## Wiki of Computer Architecture","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Derivatives":{"title":"Derivatives","content":"","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Economics":{"title":"Economics","content":"## Courses\n1. [[lecture_notes/ECON102/ECON102 MOC|ECON102 MOC]]\n\n## Books\n\n## Wiki of Economics","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Integrals":{"title":"Integrals","content":"","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Limits":{"title":"Limits","content":"","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Rules-of-Differentiation":{"title":"Rules of Differentiation","content":"","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Sequence-and-Series":{"title":"Untitled Page","content":"","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Software-Engineering":{"title":"Software Engineering","content":"## Courses\n\n## Books\n\n## Wiki of Software Engineering","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null},"/wikipages/Techniques-of-Integration":{"title":"Techniques of Integration","content":"","lastmodified":"2022-04-15T05:52:48.074971452Z","tags":null}}